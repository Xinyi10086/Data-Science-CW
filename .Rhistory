stepwise_aic_model <- step(null_model,
scope = list(lower = null_model, upper = full_model),
direction = "both",
k = log(nrow(df_train)))
summary(stepwise_aic_model)
pred_probs <- predict(stepwise_aic_model, newdata = df_test, type = "response")
pred_labels <- ifelse(pred_probs > 0.5, 1, 0)
pred_labels <- factor(pred_labels, levels = c(0, 1))
df_test$made <- factor(df_test$made, levels = c(0, 1))
confusionMatrix(data = pred_labels, reference = df_test$made)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(123)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + sqrt_seconds_left + minutes_left + quarter +
action_group + shot_type + zone_basic + is_home,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(123)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + sqrt_seconds_left + minutes_left + quarter +
action_group + zone_basic + is_home +x +y,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(123)  # 可复现性
rf_model <- randomForest(made ~ distance_ft + seconds_left + minutes_left + quarter +
action_group + zone_basic + is_home +x +y,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(123)  # 可复现性
rf_model <- randomForest(made ~ distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home +x +y,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(123)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home + x +y,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(123)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + shot_type + zone_basic + is_home + x +y,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(123)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(1)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(12)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(17)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(123)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(125)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(125)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home x + y,
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(125)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home + x + y,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(123)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home + x + y,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(12)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home + x + y,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(123)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
library(tidyverse)
library(caret)
library(randomForest)
library(pROC)
df_train <- read.csv("data/derived/curry_shots_train.csv", stringsAsFactors = FALSE)
df_test <- read.csv("data/derived/curry_shots_test.csv", stringsAsFactors = FALSE)
char_cols_train <- names(df_train)[sapply(df_train, is.character)]
df_train[char_cols_train] <- lapply(df_train[char_cols_train], as.factor)
char_cols_test <- names(df_test)[sapply(df_test, is.character)]
df_test[char_cols_test] <- lapply(df_test[char_cols_test], as.factor)
df_train$made <- as.factor(df_train$made)
# 训练随机森林模型
set.seed(111)  # 可复现性
rf_model <- randomForest(made ~ log_distance_ft + seconds_left + quarter +
action_group + zone_basic + is_home,
data = df_train, ntree = 500, importance = TRUE)
pred_probs <- predict(rf_model, newdata = df_test, type = "prob")[, 2]  # 预测为命中的概率
pred_labels <- ifelse(pred_probs >= 0.5, 1, 0)
# 若 df_test$made 存在可用于混淆矩阵
if ("made" %in% colnames(df_test)) {
df_test$made <- as.factor(df_test$made)
library(caret)
confusionMatrix(factor(pred_labels), df_test$made)
}
varImpPlot(rf_model)
# read the dataset
data <- read.table("6006350_q1_part1.txt", header = TRUE)
# read the dataset
data <- read.table("6006350_q1_part1.txt", header = TRUE)
knitr::opts_chunk$set(echo = TRUE)
# read the dataset
data <- read.table("6006350_q1_part1.txt", header = TRUE)
y <- data$y
X <- data[, -1]
# Define the ABF function
abf.fn <- function(beta, V, W) {
p <- sqrt(V / (V + W))
q <- W / (V * (V + W))
ABF <- p * exp(q * beta^2 / 2)
return(ABF)
}
# Logistic regression was fitted to each SNP, compute beta、SE、ABF
compute_abf <- function(W) {
betas <- numeric(ncol(X))
ses <- numeric(ncol(X))
abfs <- numeric(ncol(X))
for (j in 1:ncol(X)) {
model <- glm(y ~ X[, j], family = binomial)
beta <- coef(summary(model))[2, 1]
se <- coef(summary(model))[2, 2]
abfs[j] <- abf.fn(beta, se^2, W)
}
return(abfs)
}
# read the dataset
data <- read.table("6006350_q1_part1.txt", header = TRUE)
y <- data$y
X <- data[, -1]
# Define the ABF function
abf.fn <- function(beta, V, W) {
p <- sqrt(V / (V + W))
q <- -W / (V * (V + W))
ABF <- p * exp(q * beta^2 / 2)
return(ABF)
}
# Logistic regression was fitted to each SNP, compute beta、SE、ABF
compute_abf <- function(W) {
betas <- numeric(ncol(X))
ses <- numeric(ncol(X))
abfs <- numeric(ncol(X))
for (j in 1:ncol(X)) {
model <- glm(y ~ X[, j], family = binomial)
beta <- coef(summary(model))[2, 1]
se <- coef(summary(model))[2, 2]
abfs[j] <- abf.fn(beta, se^2, W)
}
return(abfs)
}
W_values <- c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7,0.8, 0.9, 1) #Different prior Variance
# SNPs with ABF < 0.1 are considered significant.
threshold <- 0.1
significant_counts <- numeric(length(W_values))
# ABF was calculated under different W and the number of SNPs below the threshold was counted.
for (i in seq_along(W_values)) {
abfs <- compute_abf(W_values[i])
significant_counts[i] <- sum(abfs < threshold)
}
